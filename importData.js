// Import data generated by pg_planscape extension
//
// @provides ImportPgPlanscapeData(dataJSON) and ObjectTypeId(object)

// Tokenizer for PostgreSQL's nodeToString() format.
function CreateTokenizer(str) {
    var r = /(?:\d+\s+\[)|(?:[(){}\]])|(?:(?:\\.|[^\s)}\]])+)/g;
    return function() {
        var result = r.exec(str);
        return result && result[0];
    }
}

// Parse PostgreSQL's nodeToString() format and return results as a JSON
// tree.
//
// @objectCallback, if any, is called to process objects.
//
function Parse(str, objectCallback = function (object, typeid) { return object; } ) {
    var getNextToken = CreateTokenizer(str);
    var keywords = {'<>': null, 'true': true, 'false': false};

    function buildAST(token) {
        if (token == '(') {
            var result = [];
            token = getNextToken();
            while (token && token != ')') {
                result.push(buildAST(token));
                token = getNextToken();
            }
            return result;
        } else if (token == '{') {
            result = {};
            var typeid = getNextToken();
            if (!typeid || typeid == '}')
                return objectCallback(result);
            result[typeid] = '';
            token = getNextToken();
            while (token && token != '}') {
                console.assert(token.startsWith(':'), token);
                var attributeName = token.substr(1);
                var attributeValue = [buildAST(getNextToken())];
                token = getNextToken();
                while (token && token != '}' && !token.startsWith(':')) {
                    attributeValue.push(buildAST(token));
                    token = getNextToken();
                }
                result[attributeName] =
                    attributeValue.length == 1 ? attributeValue[0] : attributeValue;
            }
            return objectCallback(result, typeid);
        } else if (token.endsWith('[')) {
            const numBytes = +token.match(/\d+/)[0];
            var bytes = [];
            token = getNextToken();
            while (token && token != ']') {
                bytes.push(+token);
                token = getNextToken();
            }
            bytes.length = numBytes;
            return Buffer.from(bytes).toString('base64');
        } else if (token in keywords) {
            return keywords[token];
        } else {
            // debackslash
            const asNumber = Number(token);
            return token == ''+asNumber ? asNumber : token.replace(/\\(?=.)/g, '');
        }
    }

    return buildAST(getNextToken());
}

const IndexArrayByKey = require('./indexArrayByKey').IndexArrayByKey;

// Objects from 'samples' deduplicated and flattened.
// Nested objects replaced with X-REF-s.
// OIDs resolved.
module.exports.ImportPgPlanscapeData = function (data) {
    var types = IndexArrayByKey(data.types, 'oid');
    var ops   = IndexArrayByKey(data.operators, 'oid');
    var funcs = IndexArrayByKey(data.functions, 'oid');
    var rels  = IndexArrayByKey(data.relations, 'oid');

    function resolveOid(value, oidToNameMap) {
        var oidEntry = oidToNameMap.get(value);
        return oidEntry ? oidEntry.name : value;
    }

    function augmentObject(object, typeid) {
        if (typeid == 'CONST') {
            // Get rid of trailing \0
            object[typeid] = Buffer.from(object['x-constvalue'], 'base64').
                                    slice(0,-1).toString('ascii');
            object.consttype = resolveOid(object.consttype, types);
        } else if (typeid == 'OPEXPR') {
            object[typeid] = resolveOid(object.opno, ops) || '';
            object.opfuncid = resolveOid(object.opfuncid, funcs);
            object.opresulttype = resolveOid(object.opresulttype, types);
        } else if (typeid == 'FUNCEXPR') {
            object[typeid] = resolveOid(object.funcid, funcs) || '';
            object.funcresulttype = resolveOid(object.funcresulttype, types);
        } else if (typeid == 'VAR') {
            object.vartype = resolveOid(object.vartype, types);
        } else if (typeid == 'ALIAS') {
            // Dequote column names
            var colnames = object.colnames;
            if (colnames)
                object.colnames = colnames.map(colname=>colname.substr(1,colname.length-2));
        }
    }

    var objectsSeen = new Set();
    var objects = [];

    function objectCallback(object, typeid) {
        var id = object['x-id'];
        if (typeid != 'X-REF' && !objectsSeen.has(id)) {
            augmentObject(object, typeid);
            objectsSeen.add(id);
            objects.push(object);
        }
        return {'X-REF': id};
    }

    for (sample of data.samples) {
        var result = Parse(sample.data, objectCallback);
        if (result['X-REF'] != sample.id) {
            // Alias
            result['x-id'] = sample.id;
            objects.push(result);
        } else {
            result = objects[objects.length - 1];
        }

        var oid = sample.oid;
        if (oid != undefined) {
            result['x-oid'] = oid;
            result['x-relation-name'] = resolveOid(oid, rels);
        }

        var isChosen = sample.isChosen;
        if (isChosen != undefined)
            result['x-is-chosen'] = isChosen;

        var aparent = sample['parent']; 
        if (aparent != undefined)
            result['x-parent'] = {'X-REF': aparent};

        var backtrace = sample.backtrace;
        if (backtrace != undefined)
            result['x-backtrace'] = backtrace;
    }

    // Note: this needs to be JSON-compatible
    return {'query':   data.query.replace(/^\s*EXPLAIN\s+\([^)]*\)\s*/i, ''),
            'objects': objects,
            'modules': data.modules};
}

module.exports.ObjectTypeId = function (object) {
    var typeid = '';
    for (typeid in object) break;
    return typeid;
}
